{
@standard lib
:is{ $\80 }
:weak{ $\81 }
:time{ $\82 }
:in{ $\83 }
:out{ $\84 }
:pack{ $\85 }
:unpack{ $\86 }
:clamp{ $\87 }
:data{ $\88 }
:array{ $\89 }
:len{ $\8a }
:cmp{ $\8b }
:get{ $\8c }
:set{ $\8d }
:copy{ $\8e }

:EMPTY_DATA:""
:EMPTY_ARRAY:array(0)

:_build_char_map(char_map){
 :c:7f
 ?c>-1{
  set(char_map,c,set(data(1),0,c))
  :c:c-1
 }^
 $char_map
}
:_char_map:_build_char_map(array(128))
:char(x){
 $get(_char_map,x)
}
:_NL:0a
:_SPACE:20
:_TAB:09
:NL:char(_NL)
:SPACE:char(_SPACE)
:TAB:char(_TAB)

:digit(x){
 $get(_char_map,x+30)
}
:fp(i,f){
 $(i*10000)+f
}
:int(x){
 $(x/10000)
}
:itod(x){
 ?x=0{ $"0" }
 :y:x
 :n:0
 ?y{
  :y:y/+a
  :n:n+1
 }^
 :s:data(n)
 :i:n-1
 ?x{
  set(s,i,(x%+a)+30)
  :x:x/+a
  :i:i-1
 }^
 $s
}
:dchunk(d,i,n){
 $copy(data(n),d,0,i,n)
}
:dclone(d){
 $copy(data(len(d)),d,0,0,len(d))
}
:dconcat(a,b){
 :c:data(len(a)+len(b))
 $copy(c,a,0,0,len(a))
 $copy(c,b,len(a),0,len(b))
 $c
}
:join(delimiter,datas){
 :n:len(datas)
 :i:n-1
 ?i=0{ $EMPTY_DATA }
 :new_str_n:(i*len(delimiter))
 ?i>-1{
  :new_str_n:new_str_n+len(get(datas,i))
  :i:i-1
 }^
 :new_str:data(new_str_n)
 :old_str:get(datas,0)
 copy(new_str,old_str,0,0,len(old_str))
 :new_str_i:len(old_str) 
 :i:1
 ?i<n{
  :old_str:get(datas,i)
  copy(new_str,delimiter,new_str_i,0,len(delimiter))
  :new_str_i:new_str_i+len(delimiter)
  copy(new_str,old_str,new_str_i,0,len(old_str))
  :new_str_i:new_str_i+len(old_str)
  :i:i+1
 }^
 $new_str
}
:achunk(a,i,n){
 $copy(array(n),a,0,i,n)
}
:aclone(a){
 $copy(array(len(a)),a,0,0,len(a))
}
:aconcat(a,b){
 :c:array(len(a)+len(b))
 $copy(c,a,0,0,len(a))
 $copy(c,b,len(a),0,len(b))
 $c
}
:flatten(arrays){
 :n:len(arrays)
 :i:n-1
 ?i=0{ $EMPTY_ARRAY }
 :flattened_n:0
 ?i>-1{
  :flattened_n:flattened_n+len(get(arrays,i))
  :i:i-1
 }^
 :flattened:array(flattened_n)
 :flattened_i:0 
 :i:0
 ?i<n{
  :cur_array:get(arrays,i)
  copy(flattened,cur_array,flattened_i,0,len(cur_array))
  :flattened_i:flattened_i+len(cur_array)
  :i:i+1
 }^
 $flattened 
}
:sum(ints){
 :x:0
 :n:len(ints)-1
 ?n>-1{
  :x:x+get(ints,n)
  :n:n-1
 }^
 $x
}
:select(x,a,b){
 ?x{ $a }:{ $b }
}
:default(x,def){
 ?is(x,NIL){ $def }:{ $x }
}
:empty(x){
 $is(x,NIL)|(len(x)=0)
}
:assert(a){
 ?a{ $NIL }
 !"Assertion failed"
}

@sleep - this should be like pinky `after 12ms`
@decodeb64
@b64
@xtod aka format
@dtoi aka parseint

@ logical ops
assert(1)
assert(-1)
assert(~0)
assert(~~~0)
assert(~(0&0))
assert(~(0&1))
assert(~(1&0))
assert(1&1)
assert(~(0|0))
assert(0|1)
assert(1|0)
assert(1|1)
assert((0^0)=0)
assert(1^0)
assert(0^1)
assert((1^1)=0)

@ comparison ops
assert(0=0)
assert(1=1)
assert((~-1)=0)
assert(~(0=1))
assert(~(1=0))
assert(0=0)
assert(1>0)
assert(~(0>1))
assert(~(1<0))
assert(0<1)

@ numbers
assert(100=100)
assert(~(-69=69))
assert(+34)

@ boolean globals
assert(T)
assert(~F)
assert(~T=F)
assert(T=~F)
assert(~(T=F))
assert(T=T)
assert(F=F)

@ math ops
assert(1+1=2)
assert(2-1=1)
assert(2*2=4)
assert(-45=(45*-1))
assert(4/2=2)
assert(5%2=1)

@ order of operations
@assert(1<0|2<3)
@assert(~(1<0&2<3))
@assert(~(1<0+2&2+2/2<3))

@ variable ops
:a:0
:b:1
assert(a=0)
assert(~(a=1))
assert(~(b=0))
assert(b=1)

@ control statements
?0{ assert(0) }:{ assert(1) }
?1{ assert(1) }:{ assert(0) }
?0{
 assert(0)
}:?0{
 assert(0)
}:?1{
 assert(1)
}:{
 assert(0)
}
?0{
 assert(0)
}:?0{
 assert(0)
}:?0{
 assert(0)
}:{
 assert(1)
}

@ functions
:c{ $1 }
:d{ $0 }
:D(){ $d() }
:e(a){ $a|10 }
:g{ assert(1) $1 }
assert(c())
assert(~d())
assert(e(c())=11)
assert(g())

@ try/catch
?{
 ?{
  !55
  assert(0)
 }:{
  :ef:ERR
 }
 assert(ef=55)
}:{
 assert(0)
}
assert(ef=55)

@ looping
:i:0
?i<9{
 :i:i+1
 out(i)
}^

@ strings
:test_str:"a test string"
out("hello")
out("world")

@ array
:x:100
:test_array:,3,4,5,x
out(test_array)

:dynamic_test_array:array(1)
set(dynamic_test_array,0,69)
out(get(dynamic_test_array,0)) @ print first entry in bytes

@test stdlib
assert(is(0,0))
assert(is(test_str,test_str))
:test_str_clone:"a test string"
assert(~is(test_str,test_str_clone))
assert(is(weak(test_str),test_str))
assert(clamp(2,1,3)=2)
assert(clamp(4,1,3)=3)
assert(clamp(0,1,3)=1)
:some_data_expected:"dynamic"
:some_data:data(7)
assert(len(some_data)=7)
set(some_data,0,64)
set(some_data,1,79)
set(some_data,2,6e)
set(some_data,3,61)
set(some_data,4,6d)
set(some_data,5,69)
set(some_data,6,63)
assert(get(some_data,0)=64)
assert(get(some_data,6)=63)
out(some_data)
assert(cmp(some_data,some_data_expected)=0)
assert(cmp(some_data,"dynamib")=1)
assert(cmp(some_data,"dynamid")=-1)
:some_data_copy:data(7)
assert(copy(some_data_copy,some_data,0,0,7)=some_data)
assert(copy(some_data_copy,some_data,0,0,7)=some_data)

assert(get(char(+a),0)=+a)
assert(itod(+2aaa)="10922")
assert(itod(0)="0")
assert(dchunk("foobar",2,3)="oba")
assert(join("***",(,"a","B","c"))="a***B***c")
assert(sum(,1,2,3)=6)
assert(select(F,1,0)=0)
assert(select(T,1,0)=1)
assert(default(0,9)=0)
assert(default(1,9)=1)
assert(default(NIL,9)=9)
assert(flatten(,(,0),(,1,2,3),(,4,5,6,7,8,9))=(,0,1,2,3,4,5,6,7,8,9))

@ assert(match(char(7e),"~"))
@ assert(sfirst("abc",0,"a")=0)
@ assert(sfirst("abc",0,"b")=1)
@ assert(sfirst("abc",0,"c")=2)
@ assert(sfirst("abc",0,"d")=-1)
@ assert(match(digit(0),"0"))
@ assert(match(digit(1),"1"))
@ assert(match(digit(9),"9"))

out(NL)
out("123456789helloworld345256105dynamic <- EXPECTED")
}
