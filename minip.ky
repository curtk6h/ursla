{
@there's only one way to do most ops
@instead of a<=b it's ~(a>b)

@reads code from stdin, writes vmcode to stdout

@standard lib
:in{ $\80 }
:out{ $\81 }
:alloc{ $\82 }
:get{ $\83 }
:set{ $\84 }
:ord{ $\85 }
:charat{ $\86 }
:sfind{ $\87 }
:slen{ $\88 }
:substr{ $\89 }
:_ascii_map:"\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13\14\15\16\17\18\19\1a\1b\1c\1d\1e\1f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~?"
:char(x){ $charat(_ascii_map,x) }
:digit(x){ $charat(_ascii_map,x+30) }
:itos(x){
 :s:""
 ?x=0{ $"0" }
 ?x{
  :s:digit(x%+a)+s
  :x:x/+a
 }^
 $s
}
:scount(s,i,j,x){
 :n:0
 ?i<j{
  ?charat(s,i)=x{
   :n:n+1
  }
  :i:i+1
 }^
 $n
}
:srfind(s,i,j,x){
 ?(~(i<j))&(~(charat(s,i)=x)){
  :i:i-1
 }^
 $i
}
:pad(s,x,n){
 ?n>0{
  :s:x+s
  :n:n-1
 }^
 $s
}
:NL:"\0a"

@Vector
:Vector_v(vec){ $get(vec,0) }
:Vector_n(vec){ $get(vec,1) }
:Vector_capacity(vec){ $get(vec,2) }
:Vector_get(vec,i){
 $get(get(vec,0),i)
}
:Vector_set(vec,i,x){
 $set(get(vec,0),i,x)
}
:Vector_append(vec,x){
 :v:get(vec,0)
 :n:get(vec,1)
 set(vec,1,n+1)
 $set(v,n,x)
}
:Vector_push:Vector_append
:Vector_output_chars(vec){
 :i:0
 :v:get(vec,0)
 :n:get(vec,1)
 ?i<n{
  out(get(v,i))
  :i:i+1
 }^
 $vec
}
:Vector_init(vec,capacity){
 set(vec,0,alloc(capacity))
 set(vec,1,0)
 set(vec,2,capacity)
 $vec
}
:Vector(capacity){
 $Vector_init(alloc(3),capacity)
}

@Compiler
:Compiler_vmcode(comp){ $get(comp,0) }
:Compiler_debug(comp){ $get(comp,1) }
:Compiler_words(comp){ $get(comp,2) }
:Compiler_vs(comp){ $get(comp,3) }
:Compiler_write_op(comp,op){
 Vector_append(Compiler_vmcode(comp),op)
 $comp
}
:Compiler_throw_syntax_err(code,i,msg){
 :line_num:scount(code,0,i,NL)+1
 :line_start:srfind(code,i,0,NL)+1
 :line:substr(code,line_start,sfind(code,i,NL))
 :line_arrow:pad("^"," ",i-line_start)
 !"Syntax error on line "+itos(line_num)+": "+msg+NL+line+NL+line_arrow
}
:Compiler_parse_char(code,i,chars){
 :c:charat(code,i)
 ?c="@"{
   ?~(c=""){
   }
 }
 ?sfind(chars,0,charat(code,i))=-1{
  Compiler_throw_syntax_err(code,i,"Expected "+chars+" got "+charat(code,i))
 }
 $i+1
}
:Compiler_c_statement(comp,code,i){
 ?Compiler_debug(comp)&(charat(code,i)=NL){
   Compiler_write_op(comp,NL)
 }
 $Compiler_parse_char(code,i,"\0a ")
}
:Compiler_c_code_block(comp,code,i){
 :i:Compiler_parse_char(code,i,"{")
 ?~(charat(code,i)="}"){
  :i:Compiler_c_statement(comp,code,i)
 }^
 $i+1
}
:Compiler_compile(comp,code){
 :vmcode:Compiler_vmcode(comp)
 :i:0
 :i:Compiler_c_code_block(comp,code,i)
 $comp
}
:Compiler_output_chars(comp){
 Vector_output_chars(Compiler_vmcode(comp))
 $comp
}
:Compiler_init_words(words){
 Vector_append(words,"NIL")
 Vector_append(words,"ERR")
 Vector_append(words,"F")
 Vector_append(words,"T")
 $words
}
:Compiler_init_vs(vs){
 :vars:Vector(100)
 Vector_append(vars,0)
 Vector_append(vars,1)
 Vector_append(vars,2)
 Vector_append(vs,vars)
 $vs
}
:Compiler_init(comp){
 set(comp,0,Vector(+ffff))
 set(comp,1,T)
 set(comp,2,Compiler_init_words(Vector(4)))
 set(comp,3,Compiler_init_vs(Vector(1)))
 $comp
}
:Compiler{
 $Compiler_init(alloc(4))
}
:comp:Compiler()
Compiler_compile(comp,in())
Compiler_output_chars(comp)
out("done")
}