{
@there's only one way to do most ops
@instead of a<=b it's ~(a>b)
@Implement conversion functions:
@itoc,itos
@stoi
@ctoi
@int8,int16,int32
@uint8,uint16,uint32
@pack8,pack16
@unpack8,unpack16
@sum,concat(agg funcs. stop allowing + for str)
@:concat(*args){args} @ stores vars in args variable

@reads code from stdin, writes vmcode to stdout

@standard lib
:in{ $\80 }
:out{ $\81 }
:array{ $\82 }
:alen{ $\83 }
:get{ $\84 }
:set{ $\85 }
:str{ $\86 }
:slen{ $\87 }
:sget{ $\88 }
:sset{ $\89 }
:byte{ $\8a }
:char(x){ $\8b }
:sfirst{ $\8c }
:substr{ $\8d }
:shl{ $\8e }
:shr{ $\8f }
:digit(x){ $sget(_ascii_map,x+30) }
:itos(x){
 :s:""
 ?x=0{ $"0" }
 ?x{
  :s:digit(x%+a)+s
  :x:x/+a
 }^
 $s
}
:scount(s,i,j,x){
 :n:0
 ?i<j{
  ?sget(s,i)=x{
   :n:n+1
  }
  :i:i+1
 }^
 $n
}
:slast(s,i,j,x){
 ?j>i{
  ?sget(s,j)=x{
   $j
  }
  :j:j-1
 }^
 $-1
}
:lpad(s,x,n){
 ?n>0{
  :s:x+s
  :n:n-1
 }^
 $s
}
:afirst(a,x){
 :i:0
 :j:alen(a)
 ?i<j{
  ?get(a,i)=x{
   $i
  }
  :i:i+1
 }
 $-1
}
:map(a,f){
 :i:0
 :j:alen(a)
 ?i<j{
  set(a,i,f(get(a,i)))
  :i:i+1
 }
 $a
}
:is_digit(c){
 :x:ord(c)
 $((x>2f)&(x<3a))
}
:is_hex_digit(c){
 :x:ord(c)
 $((x>2f)&(x<3a))|((x>60)&(x<67))
}
:is_alpha(c){
 :x:ord(c)
 $((x>40)&(x<5b))|((x>60)&(x<79))
}
:is_word(c){
 :x:ord(c)
 $((x>40)&(x<5b))|((x>60)&(x<79))|((x>2f)&(x<3a))|(x=5f)
}

:NL:char(0a)

@Vector
:Vector_v(vec){ $get(vec,0) }
:Vector_n(vec){ $get(vec,1) }
:Vector_capacity(vec){ $get(vec,2) }
:Vector_get(vec,i){
 $get(get(vec,0),i)
}
:Vector_set(vec,i,x){
 $set(get(vec,0),i,x)
}
:Vector_append(vec,x){
 :v:get(vec,0)
 :n:get(vec,1)
 set(vec,1,n+1)
 $set(v,n,x)
}
:Vector_push:Vector_append
:Vector_output_chars(vec){
 :i:0
 :v:get(vec,0)
 :n:get(vec,1)
 ?i<n{
  out(get(v,i))
  :i:i+1
 }^
 $vec
}
:Vector_init(vec,capacity){
 set(vec,0,array(capacity))
 set(vec,1,0)
 set(vec,2,capacity)
 $vec
}
:Vector(capacity){
 $Vector_init(array(3),capacity)
}

@Compiler
:Compiler_vmcode(comp){ $get(comp,0) }
:Compiler_vmcode_idx(comp){ $get(comp,1) }
:Compiler_set_vmcode_idx(comp,x){ $set(comp,1,x) }
:Compiler_debug(comp){ $get(comp,2) }
:Compiler_words(comp){ $get(comp,3) }
:Compiler_vs(comp){ $get(comp,4) }
:Compiler_append_op(comp,op){
 :i:Compiler_vmcode_idx(comp)
 sset(Compiler_vmcode(comp),i,op)
 Compiler_set_vmcode_idx(comp,i+1)
 $comp
}
:Compiler_encode_byte(comp,i,x){
 :vmcode:Compiler_vmcode(comp)
 sset(vmcode,i+0,shr(x,+4)&+f)
 sset(vmcode,i+1,x&+f)
 $comp
}
:Compiler_encode_short(comp,i,x){
 :vmcode:Compiler_vmcode(comp)
 sset(vmcode,i+0,shr(x,+c)&+f)
 sset(vmcode,i+1,shr(x,+8)&+f)
 sset(vmcode,i+2,shr(x,+4)&+f)
 sset(vmcode,i+3,x&+f)
 $comp
}
:Compiler_append_op_w_byte(comp,op,x){
 :i:Compiler_vmcode_idx(comp)
 Vector_append(Compiler_vmcode(comp),op)
 Compiler_encode_byte(comp,i,x)
 Compiler_set_vmcode_idx(i+3)
 $comp
}
:Compiler_append_op_w_short(comp,op,x){
 :i:Compiler_vmcode_idx(comp)
 Vector_append(Compiler_vmcode(comp),op)
 Compiler_encode_short(comp,i,x)
 Compiler_set_vmcode_idx(i+5)
 $comp
}
:Compiler_append_op_w_addr:Compiler_append_op_w_short
:Compiler_throw_syntax_err(code,i,msg){
 :line_num:scount(code,0,i,NL)+1
 :line_start:slast(code,0,i,NL)+1
 :line:substr(code,line_start,sfirst(code,i,NL))
 :line_arrow:lpad("^"," ",i-line_start)
 !"Syntax error on line "+itos(line_num)+": "+msg+NL+line+NL+line_arrow
}
:Compiler_parse_char(code,i,chars){
 :c:sget(code,i)
 ?sfirst(chars,0,c)=-1{
  Compiler_throw_syntax_err(code,i,"Expected "+chars+" got "+c)
 }
 $i+1
}
:Compiler_skip_ws(code,i){
 ?get(code,i)=" "{
  :i:i+1
 }
 $i
}
:Compiler_c_statement(comp,code,i){
 :i:Compiler_skip_ws(code,i)
 :c:sget(code,i)
 ?c="@"{
  ?~(sget(code,i)=NL){
   :i:i+1
  }^
  ?Compiler_debug(comp){
   @write out comment
  }
 }
 ?Compiler_debug(comp)&(sget(code,i)=NL){
   Compiler_append_op(comp,NL)
 }
 $Compiler_parse_char(code,i,NL)
}
:Compiler_c_code_block(comp,code,i){
 :i:Compiler_parse_char(code,i,"{")
 ?~(sget(code,i)="}"){
  :i:Compiler_c_statement(comp,code,i)
 }^
 $i+1
}
:Compiler_compile(comp,code){
 :vmcode:Compiler_vmcode(comp)
 :i:0
 :i:Compiler_c_code_block(comp,code,i)
 $comp
}
:Compiler_output_chars(comp){
 Vector_output_chars(Compiler_vmcode(comp))
 $comp
}
:Compiler_init_words(words){
 Vector_append(words,"NIL")
 Vector_append(words,"ERR")
 Vector_append(words,"F")
 Vector_append(words,"T")
 $words
}
:Compiler_init_vs(vs){
 :vars:Vector(100)
 Vector_append(vars,0)
 Vector_append(vars,1)
 Vector_append(vars,2)
 Vector_append(vs,vars)
 $vs
}
:Compiler_init(comp){
 set(comp,0,str(char(00),+ffff))
 set(comp,1,0)
 set(comp,2,T)
 set(comp,3,Compiler_init_words(Vector(4)))
 set(comp,4,Compiler_init_vs(Vector(1)))
 $comp
}
:Compiler{
 $Compiler_init(array(4))
}
:comp:Compiler()
Compiler_compile(comp,in())
Compiler_output_chars(comp)
out("done")
}