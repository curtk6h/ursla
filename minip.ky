{
@standard lib
:is{ $\80 }
:weak{ $\81 }
:time{ $\82 }
:in{ $\83 }
:out{ $\84 }
:pack{ $\85 }
:unpack{ $\86 }
:clamp{ $\87 }
:data{ $\88 }
:array{ $\89 }
:len{ $\8a }
:cmp{ $\8b }
:get{ $\8c }
:set{ $\8d }
:copy{ $\8e }

:EMPTY_DATA:""
:EMPTY_ARRAY:array(0)

:_build_char_map(char_map){
 :c:7f
 ?c>-1{
  set(char_map,c,set(data(1),0,c))
  :c:c-1
 }^
 $char_map
}
:_char_map:_build_char_map(array(128))
:char(x){
 $get(_char_map,x)
}
:_NL:0a
:_SPACE:20
:_TAB:09
:NL:char(_NL)
:SPACE:char(_SPACE)
:TAB:char(_TAB)

:digit(x){
 $get(_char_map,x+30)
}
:fp(i,f){
 $(i*10000)+f
}
:int(x){
 $(x/10000)
}
:itod(x){
 ?x=0{ $"0" }
 :y:x
 :n:0
 ?y{
  :y:y/+a
  :n:n+1
 }^
 :s:data(n)
 :i:n-1
 ?x{
  set(s,i,(x%+a)+30)
  :x:x/+a
  :i:i-1
 }^
 $s
}
:dchunk(d,i,n){
 $copy(data(n),d,0,i,n)
}
:dclone(d){
 $copy(data(len(d)),d,0,0,len(d))
}
:dconcat(a,b){
 :c:data(len(a)+len(b))
 $copy(c,a,0,0,len(a))
 $copy(c,b,len(a),0,len(b))
 $c
}
:join(delimiter,datas){
 :n:len(datas)
 :i:n-1
 ?i=0{ $EMPTY_DATA }
 :new_str_n:(i*len(delimiter))
 ?i>-1{
  :new_str_n:new_str_n+len(get(datas,i))
  :i:i-1
 }^
 :new_str:data(new_str_n)
 :old_str:get(datas,0)
 copy(new_str,old_str,0,0,len(old_str))
 :new_str_i:len(old_str) 
 :i:1
 ?i<n{
  :old_str:get(datas,i)
  copy(new_str,delimiter,new_str_i,0,len(delimiter))
  :new_str_i:new_str_i+len(delimiter)
  copy(new_str,old_str,new_str_i,0,len(old_str))
  :new_str_i:new_str_i+len(old_str)
  :i:i+1
 }^
 $new_str
}
:achunk(a,i,n){
 $copy(array(n),a,0,i,n)
}
:aclone(a){
 $copy(array(len(a)),a,0,0,len(a))
}
:aconcat(a,b){
 :c:array(len(a)+len(b))
 $copy(c,a,0,0,len(a))
 $copy(c,b,len(a),0,len(b))
 $c
}
:flatten(arrays){
 :n:len(arrays)
 :i:n-1
 ?i=0{ $EMPTY_ARRAY }
 :flattened_n:0
 ?i>-1{
  :flattened_n:flattened_n+len(get(arrays,i))
  :i:i-1
 }^
 :flattened:array(flattened_n)
 :flattened_i:0 
 :i:0
 ?i<n{
  :cur_array:get(arrays,i)
  copy(flattened,cur_array,flattened_i,0,len(cur_array))
  :flattened_i:flattened_i+len(cur_array)
  :i:i+1
 }^
 $flattened 
}
:sum(ints){
 :x:0
 :n:len(ints)-1
 ?n>-1{
  :x:x+get(ints,n)
  :n:n-1
 }^
 $x
}
:select(x,a,b){
 ?x{ $a }:{ $b }
}
:default(x,def){
 ?is(x,NIL){ $def }:{ $x }
}
:empty(x){
 $is(x,NIL)|(len(x)=0)
}
:count(a,i,j,x){
 :n:0
 ?i<j{
  ?is(get(a,i),x){
   :n:n+1
  }
  :i:i+1
 }^
 $n
}
:first(a,i,j,x){
 ?i<j{
  ?is(get(a,i),x){
   $i
  }
  :i:i+1
 }
 $-1
}
:last(a,i,j,x){
 ?j>i{
  ?is(get(a,j),x){
   $j
  }
  :j:j-1
 }^
 $-1
}
:pad(s,x,n){
 ?n>0{
  :s:x+s
  :n:n-1
 }^
 $s
}
:map(a,f){
 :i:0
 :j:len(a)
 ?i<j{
  set(a,i,f(get(a,i)))
  :i:i+1
 }
 $a
}
:map{
 \00
}
:is_digit(c){
 :x:ord(c)
 $((x>2f)&(x<3a))
}
:is_hex_digit(c){
 :x:ord(c)
 $((x>2f)&(x<3a))|((x>60)&(x<67))
}
:is_alpha(c){
 :x:ord(c)
 $((x>40)&(x<5b))|((x>60)&(x<79))
}
:is_word(c){
 :x:ord(c)
 $((x>40)&(x<5b))|((x>60)&(x<79))|((x>2f)&(x<3a))|(x=5f)
}

@Vector
:Vector_v(vec){ $get(vec,0) }
:Vector_n(vec){ $get(vec,1) }
:Vector_capacity(vec){ $get(vec,2) }
:Vector_get(vec,i){
 $get(get(vec,0),i)
}
:Vector_set(vec,i,x){
 $set(get(vec,0),i,x)
}
:Vector_append(vec,x){
 :v:get(vec,0)
 :n:get(vec,1)
 set(vec,1,n+1)
 $set(v,n,x)
}
:Vector_push:Vector_append
:Vector_output_chars(vec){
 :i:0
 :v:get(vec,0)
 :n:get(vec,1)
 ?i<n{
  out(get(v,i))
  :i:i+1
 }^
 $vec
}
:Vector_init(vec,capacity){
 set(vec,0,array(capacity))
 set(vec,1,0)
 set(vec,2,capacity)
 $vec
}
:Vector(capacity){
 $Vector_init(array(3),capacity)
}

@Compiler
:Compiler_vmcode(comp){ $get(comp,0) }
:Compiler_vmcode_idx(comp){ $get(comp,1) }
:Compiler_set_vmcode_idx(comp,x){ $set(comp,1,x) }
:Compiler_debug(comp){ $get(comp,2) }
:Compiler_words(comp){ $get(comp,3) }
:Compiler_vs(comp){ $get(comp,4) }
:Compiler_append_op(comp,op){
 :i:Compiler_vmcode_idx(comp)
 sset(Compiler_vmcode(comp),i,op)
 Compiler_set_vmcode_idx(comp,i+1)
 $comp
}
:Compiler_encode_byte(comp,i,x){
 :vmcode:Compiler_vmcode(comp)
 sset(vmcode,i+0,shr(x,+4)&+f)
 sset(vmcode,i+1,x&+f)
 $comp
}
:Compiler_encode_short(comp,i,x){
 :vmcode:Compiler_vmcode(comp)
 sset(vmcode,i+0,shr(x,+c)&+f)
 sset(vmcode,i+1,shr(x,+8)&+f)
 sset(vmcode,i+2,shr(x,+4)&+f)
 sset(vmcode,i+3,x&+f)
 $comp
}
:Compiler_append_op_w_byte(comp,op,x){
 :i:Compiler_vmcode_idx(comp)
 Vector_append(Compiler_vmcode(comp),op)
 Compiler_encode_byte(comp,i,x)
 Compiler_set_vmcode_idx(i+3)
 $comp
}
:Compiler_append_op_w_short(comp,op,x){
 :i:Compiler_vmcode_idx(comp)
 Vector_append(Compiler_vmcode(comp),op)
 Compiler_encode_short(comp,i,x)
 Compiler_set_vmcode_idx(i+5)
 $comp
}
:Compiler_append_op_w_addr:Compiler_append_op_w_short
:Compiler_throw_syntax_err(code,i,msg){
 :line_num:scount(code,0,i,NL)+1
 :line_start:slast(code,0,i,NL)+1
 :line:substr(code,line_start,sfirst(code,i,NL))
 :line_arrow:pad("^"," ",i-line_start)
 !"Syntax error on line "+itos(line_num)+": "+msg+NL+line+NL+line_arrow
}
:Compiler_parse_char(code,i,chars){
 :c:sget(code,i)
 ?sfirst(chars,0,c)=-1{
  Compiler_throw_syntax_err(code,i,"Expected "+chars+" got "+c)
 }
 $i+1
}
:Compiler_skip_ws(code,i){
 ?get(code,i)=" "{
  :i:i+1
 }
 $i
}
:Compiler_c_statement(comp,code,i){
 :i:Compiler_skip_ws(code,i)
 :c:sget(code,i)
 ?c="@"{
  ?~(sget(code,i)=NL){
   :i:i+1
  }^
  ?Compiler_debug(comp){
   @write out comment
  }
 }
 ?Compiler_debug(comp)&(sget(code,i)=NL){
   Compiler_append_op(comp,NL)
 }
 $Compiler_parse_char(code,i,NL)
}
:Compiler_c_code_block(comp,code,i){
 :i:Compiler_parse_char(code,i,"{")
 ?~(sget(code,i)="}"){
  :i:Compiler_c_statement(comp,code,i)
 }^
 $i+1
}
:Compiler_compile(comp,code){
 :vmcode:Compiler_vmcode(comp)
 :i:0
 :i:Compiler_c_code_block(comp,code,i)
 $comp
}
:Compiler_output_chars(comp){
 Vector_output_chars(Compiler_vmcode(comp))
 $comp
}
:Compiler_init_words(words){
 Vector_append(words,"NIL")
 Vector_append(words,"ERR")
 Vector_append(words,"F")
 Vector_append(words,"T")
 $words
}
:Compiler_init_vs(vs){
 :vars:Vector(100)
 Vector_append(vars,0)
 Vector_append(vars,1)
 Vector_append(vars,2)
 Vector_append(vs,vars)
 $vs
}
:Compiler_init(comp){
 set(comp,0,str(char(00),+ffff))
 set(comp,1,0)
 set(comp,2,T)
 set(comp,3,Compiler_init_words(Vector(4)))
 set(comp,4,Compiler_init_vs(Vector(1)))
 $comp
}
:Compiler{
 $Compiler_init(array(4))
}
:comp:Compiler()
Compiler_compile(comp,in())
Compiler_output_chars(comp)
out("done")
}